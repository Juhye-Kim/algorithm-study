/*  계수정렬(Count Sort) 구현
    - 최악 O(N + K)
    - 특정 조건 부합시에만 사용 가능, 매우 빠름
    - 조건 : 데이터 크기 범위가 제한되어, 정수형태로 표현할 수 있어야함
          => 최댓값 - 최솟값이 1,000,000 넘지 않을 때 효과적 !
    - 효율적인 경우 : 동일값 가지는 데이터가 여러개 등장할 때 (ex. 100점만점 학생성적 정렬)
    - 비효율적인 경우 : 0, 999999 두개 데이터만 존재해도, 1000000 크기 배열 필요
    - 퀵정렬은 평균적으로 빠르기 때문에, 데이터 특성 파악 어려우면 퀵정렬이 유리

      1. 모든 범위를 담는 초기배열 선언 (최댓값 + 1 크기)
        ex. 최솟값 0, 최댓값 9 -> 크기 10짜리 배열 선언 (값은 0으로 초기화)
      2. 데이터를 하나씩 확인하며, 데이터 값과 동일한 인덱스 데이터를 1씩 증가시킴
      => 배열에는 각 데이터가 몇 번 등장했는지 횟수가 기록됨, 순서대로 그대로 출력하면 끝!
 */

function solution(arr) {
  let count = Array(Math.max(...arr) + 1).fill(0);
  let sorted = [];
  arr.forEach((num) => {
    count[num]++;
  });
  count.forEach((num, idx) => {
    for (let i = 0; i < num; i++) {
      if (num !== 0) sorted.push(idx);
    }
  });
  return sorted;
}

let input = [7, 15, 9, 0, 3, 10, 6, 2, 4, 8];
console.log(solution(input));
